package edu.kit.sdq.storagebenchmarkharness.benchmarks.ffsb;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Level;

import com.almworks.sqlite4java.SQLiteConnection;
import com.almworks.sqlite4java.SQLiteException;
import com.almworks.sqlite4java.SQLiteStatement;
import com.beust.jcommander.JCommander;
import com.beust.jcommander.Parameter;
import com.beust.jcommander.ParameterException;
import com.beust.jcommander.internal.Maps;
import com.google.common.collect.Lists;

import edu.kit.sdq.storagebenchmarkharness.Logger;
import edu.kit.sdq.storagebenchmarkharness.SBHModel.DependentVariables;
import edu.kit.sdq.storagebenchmarkharness.SBHModel.DependentVariablesValue;
import edu.kit.sdq.storagebenchmarkharness.SBHModel.FileSystem;
import edu.kit.sdq.storagebenchmarkharness.SBHModel.IndependentVariablesOfFFSB;
import edu.kit.sdq.storagebenchmarkharness.SBHModel.IndependentVariablesOfSut;
import edu.kit.sdq.storagebenchmarkharness.SBHModel.SBHModelFactory;
import edu.kit.sdq.storagebenchmarkharness.SBHModel.Scheduler;
import edu.kit.sdq.storagebenchmarkharness.datastore.DataStore;
import edu.kit.sdq.storagebenchmarkharness.datastore.sqlite.SQLiteDataStore;

/**
 * This class can be used to import logfiles from FFSB into the database. This
 * is mostly useful if ffsb has been run without the Benchmark Harness and the
 * results should be included in the analysis. This class is only a workaround
 * for this specific situation. It is not well tested and the results should be
 * checked after importing.
 * 
 * @author Dominik Bruhn, Axel Busch (axel.busch@student.kit.edu)
 * 
 */
public final class FFSBImporter
{
	private static final Logger LOGGER = Logger.getLogger(FFSBImporter.class);

	public static void main(String[] args)
	{
		// Parse Parameters
		FSSBImportParameters fip = new FSSBImportParameters();
		JCommander jcomm = new JCommander(fip);
		try
		{
			jcomm.parse(args);
		} catch (ParameterException e)
		{
			jcomm.usage();
			System.exit(1);
		}

		if (fip.quiet)
		{
			((ch.qos.logback.classic.Logger) LoggerFactory.getLogger("edu.kit.sdq.storagebenchmarkcontroller")).setLevel(Level.WARN);
		}

		boolean success;
		if (fip.confpath != null)
		{
			if (fip.hostId == null)
			{
				jcomm.usage();
				System.err.println("You must supply a hostId");
				System.exit(2);
			}
			success = doImportFromFFSBConf(fip.dbpath, fip.confpath, fip.logpath, fip.hostId);
		} else
		{
			if (fip.confDatabases == null || fip.confDatabases.size() == 0)
			{
				jcomm.usage();
				System.err.println("You must provide at least one restoreDatabase");
				System.exit(2);
			}
			success = doImportFromDB(fip.dbpath, fip.logpath, fip.confDatabases.toArray(new String[]
			{}));
		}

		if (!success)
		{
			System.exit(1);
		}
	}

	private static class FSSBImportParameters
	{
		@Parameter(names =
		{ "--quiet", "-q" }, description = "Quiet mode, do not display debug messages")
		private boolean quiet = false;

		@Parameter(names =
		{ "--database", "-d" }, description = "Database path where the data should be saved", required = true)
		private String dbpath;

		@Parameter(names =
		{ "--ffsblog" }, description = "FFSB-Log File", required = true)
		private String logpath;

		@Parameter(names =
		{ "--ffsbconf" }, description = "FFSB-Configuration File")
		private String confpath;

		@Parameter(names =
		{ "--host" }, description = "Host identifier")
		private String hostId;

		@Parameter(names =
		{ "--confdb" }, description = "Database to search for the configuration")
		private List<String> confDatabases;
	}

	/**
	 * Do the actual importing in case we have a ffsb-configuration and a
	 * ffsb-logfile.
	 * 
	 * @param database
	 *            A path to a SQLite database where the data from the logfile
	 *            will be saved to.
	 * @param conffile
	 *            A FFSB-Configuration file which was used to run FFSB
	 * @param logfile
	 *            The logfile which was generated by FFSB when it was run with
	 *            the conffile provided.
	 * @param hostId
	 *            A identifier for the host where the results have been
	 *            acquired.
	 */
	private static boolean doImportFromFFSBConf(String database, String conffile, String logfile, String hostId)
	{
		String benchmarkId = "FFSBenchmarkDriver";
		String identifier = String.format("Import from '%s' / '%s'", conffile, logfile);

		try
		{
			IndependentVariablesOfFFSB ffsbVars = SBHModelFactory.eINSTANCE.createIndependentVariablesOfFFSB();
			IndependentVariablesOfSut sutVars = SBHModelFactory.eINSTANCE.createIndependentVariablesOfSut();

			BufferedReader reader = new BufferedReader(new FileReader(conffile));
			String line;
			Map<String, String> conf = Maps.newHashMap();
			while ((line = reader.readLine()) != null)
			{
				LOGGER.debug("Found line %s", line);

				if (line.contains("="))
				{
					String[] p = line.split("=");
					conf.put(p[0].trim(), p[1].trim());
				}
			}

			reader.close();

			LOGGER.debug("Afterwards");
			LOGGER.debug("Found settings: %s", conf);

			if (conf.size() == 0)
			{
				LOGGER.error("Configuration contains no properties.");
				return false;
			}

			// Filesetsize
			if (conf.containsKey("init_size"))
			{
				String fileset = conf.get("init_size");
				if (fileset.endsWith("m"))
				{
					ffsbVars.setFilesetSize(Integer.parseInt(fileset.substring(0, fileset.length() - 1)));
				} else
				{
					throw new IllegalArgumentException("Unkown unit for fileset " + fileset);
				}
			} else
			{
				throw new IllegalArgumentException("Don't know how to calculate FileSet and FileSize");
			}

			// Readblocksize
			String readblocksize = conf.get("read_blocksize");
			if (readblocksize.endsWith("k"))
			{
				ffsbVars.setReadBlockSize(Integer.parseInt(readblocksize.substring(0, readblocksize.length() - 1)));
			} else
			{
				throw new IllegalArgumentException("Unkown unit for readblocksize " + readblocksize);
			}

			// Writeblocksize
			String writeblocksize = conf.get("write_blocksize");
			if (writeblocksize.endsWith("k"))
			{
				ffsbVars.setWriteBlockSize(Integer.parseInt(writeblocksize.substring(0, writeblocksize.length() - 1)));
			} else
			{
				throw new IllegalArgumentException("Unkown unit for writeblocksize " + writeblocksize);
			}

			// Sequential
			String readRandom = conf.get("read_random");
			String writeRandom = conf.get("write_random");

			if (!readRandom.equals(writeRandom))
			{
				throw new IllegalArgumentException("readRandom and writeRandom do not match: " + readRandom + "/" + writeRandom);
			}
			ffsbVars.setSequentialRead(readRandom.equals("0"));
			ffsbVars.setSequentialWrite(readRandom.equals("0"));

			// Thread count
			ffsbVars.setThreadCount(Integer.parseInt(conf.get("num_threads")));

			// Weights
			int readWeight = Integer.parseInt(conf.get("read_weight"));
			int writeWeight = Integer.parseInt(conf.get("write_weight"));
			int writeFsyncWeight = Integer.parseInt(conf.get("write_fsync_weight"));

			if (writeWeight > 0 && writeFsyncWeight > 0)
			{
				throw new IllegalArgumentException("writeWeight and writeFsyncWeight are both >0: " + writeWeight + "/" + writeFsyncWeight);
			}

			if (writeFsyncWeight > 0)
			{
				ffsbVars.setWriteFsync(true);
				writeWeight = writeFsyncWeight;
			} else
			{
				ffsbVars.setWriteFsync(false);
			}

			ffsbVars.setReadPercentage((int) Math.round((((double) readWeight) / ((double) readWeight + (double) writeWeight)) * 100d));

			// Other values
			ffsbVars.setDirectIO(conf.get("directio").equals("1"));

			// TODO: Correct values missing
			sutVars.setFileSystem(FileSystem.EXT4);
			sutVars.setScheduler(Scheduler.NOOP);

			LOGGER.debug("BenchConf is %s", ffsbVars);
			LOGGER.debug("SutConf is %s", sutVars);

			if (true)
			{
				throw new IllegalArgumentException("This method is not adapted to most recent EMF-Changes");
			}

			// Actual import
			DataStore ds = new SQLiteDataStore(database);
			ds.setupDataStore();
			ds.storeConfigurationRun(identifier);

			BufferedReader logRader = new BufferedReader(new FileReader(logfile));
			List<DependentVariablesValue> values = FFSBenchmarkDriver.parseFFSBLogAndSave(logRader, true, null);
			logRader.close();

			DependentVariables result = SBHModelFactory.eINSTANCE.createDependentVariables();
			result.getValues().clear();
			result.getValues().addAll(values);
			List<DependentVariables> resultList = Lists.newArrayList();
			resultList.add(result);

			ds.storeExperimentResults(1, hostId, benchmarkId, 1, "imported", sutVars, ffsbVars, resultList);
			ds.finishConfigurationRun();
			ds.closeDataStore();

			return true;
		} catch (FileNotFoundException e)
		{
			LOGGER.error("File not found", e);
			return false;
		} catch (IOException e)
		{
			LOGGER.error("IOException", e);
			return false;
		}
	}

	private static boolean doImportFromDB(String outputDatabase, String logfile, String[] rescueDBs)
	{
		try
		{
			String uid = logfile.substring(logfile.length() - 46, logfile.length() - 10);
			LOGGER.error("Uid is %s", uid);

			// Check if this uuid already is contained in the outputDatabase
			if (new File(outputDatabase).exists())
			{
				SQLiteConnection dbCheck = new SQLiteConnection(new File(outputDatabase));
				dbCheck.open(false);
				dbCheck.setBusyTimeout(100000);

				SQLiteStatement cstmt = dbCheck.prepare("SELECT runId FROM runs WHERE expUid=?;");
				cstmt.bind(1, uid);
				if (cstmt.step())
				{
					LOGGER.error("An entry in the database %s already exists with uid %s", outputDatabase, uid);
					return false;
				}
			}

			for (String rescueDB : rescueDBs)
			{
				LOGGER.debug("Trying from db %s", rescueDB);

				SQLiteConnection db = new SQLiteConnection(new File(rescueDB));
				db.open(false);
				db.setBusyTimeout(100000);

				SQLiteStatement stmt = db.prepare("SELECT runId, filesystem, scheduler, directIO, filesetsize, filesize, opsperfile, readblocksize, "
						+ "readpercentage,runtime, sequentialread, sequentialwrite, threadcount, warmuptime, "
						+ "writeblocksize, writefsync, crIdentifier, hostId " + "FROM runs  LEFT JOIN ffsbIndependentVars USING (runId) "
						+ "LEFT JOIN configurationRuns USING (crId) "
						+ "WHERE (benchmarkId=\"FFSBenchmarkDriver\" OR benchmarkId=\"FFSBBenchmark\") " + "AND expUid=?;");
				stmt.bind(1, uid);
				if (stmt.step())
				{
					LOGGER.debug("Found in db %s, runId is %d", rescueDB, stmt.columnInt(0));

					IndependentVariablesOfFFSB ffsbVars = SBHModelFactory.eINSTANCE.createIndependentVariablesOfFFSB();
					IndependentVariablesOfSut sutVars = SBHModelFactory.eINSTANCE.createIndependentVariablesOfSut();

					sutVars.setFileSystem(FileSystem.get(stmt.columnString(1)));
					sutVars.setScheduler(Scheduler.get(stmt.columnString(2)));

					ffsbVars.setDirectIO(stmt.columnInt(3) == 1);
					ffsbVars.setFilesetSize(stmt.columnInt(4));
					ffsbVars.setFileSize(stmt.columnInt(5));
					ffsbVars.setOpsPerFile(stmt.columnInt(6));
					ffsbVars.setReadBlockSize(stmt.columnInt(7));
					ffsbVars.setReadPercentage(stmt.columnInt(8));
					ffsbVars.setRunTime(stmt.columnInt(9));
					ffsbVars.setSequentialRead(stmt.columnInt(10) == 1);
					ffsbVars.setSequentialWrite(stmt.columnInt(11) == 1);
					ffsbVars.setThreadCount(stmt.columnInt(12));
					ffsbVars.setWarmUpTime(stmt.columnInt(13));
					ffsbVars.setWriteBlockSize(stmt.columnInt(14));
					ffsbVars.setWriteFsync(stmt.columnInt(15) == 1);

					LOGGER.debug("BenchConf is %s", ffsbVars);
					LOGGER.debug("SutConf is %s", sutVars);

					String cfId = String.format("%s (Import from %s and db %s at '%s')", stmt.columnString(16), logfile, rescueDB,
							new Date().toString());
					String hostId = stmt.columnString(17);

					// Actual import
					DataStore ds = new SQLiteDataStore(outputDatabase);
					ds.setupDataStore();
					ds.storeConfigurationRun(cfId);

					BufferedReader logRader = new BufferedReader(new FileReader(logfile));
					List<DependentVariablesValue> values = FFSBenchmarkDriver.parseFFSBLogAndSave(logRader, true, null);
					logRader.close();

					DependentVariables result = SBHModelFactory.eINSTANCE.createDependentVariables();
					result.getValues().clear();
					result.getValues().addAll(values);
					List<DependentVariables> resultList = Lists.newArrayList();
					resultList.add(result);

					ds.storeExperimentResults(1, hostId, "FFSBenchmarkDriver", 1, uid, sutVars, ffsbVars, resultList);
					ds.finishConfigurationRun();
					ds.closeDataStore();

					stmt.dispose();
					db.dispose();

					return true;
				}

				stmt.dispose();
				db.dispose();
			}

			LOGGER.error("The uuid %s could not be found in the databases", uid);
			return false;
		} catch (SQLiteException e)
		{
			LOGGER.error("SQLite Exception", e);
			return false;
		} catch (IOException e)
		{
			LOGGER.error("IOException", e);
			return false;
		}
	}
}
